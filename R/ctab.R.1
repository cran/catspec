# ctab: oneway, twoway, multiway percentage tables
# first argument must consist of one or more factors
# or a table object (class table, xtabs, or ftable)
# digits: number of digits after the decimal (default 2)
# type: "n" for counts, "row", "column" or "total"
# for percentages (default "n")
# row.vars:
# col.vars: same usage as ftable, ignored for one- and
# two-way tables
# percentages: FALSE==> proportions are presented rather
# than percentages (default TRUE)

# comments to John Hendrickx <John_Hendrickx@yahoo.com>

ctab<-function(...,digits=2,
		type=NULL,
		row.vars=NULL, col.vars=NULL,
		percentages=TRUE) {
	if (attributes(...)$class=="factor") {
		# create a table if the arguments are factors
		tbl<-table(...)
	}
	else if ("table" %in% class(...) || class(...)=="ftable") {
		# the argument is a table object (table, xtabs, ftable)
		tbl<-eval(...)
	}
	else {
		stop("first argument must be either factors or a table object")
	}

	if (is.null(type)) type<-"n"
	type<-match.arglist(type,c("n", "row", "column", "total"))

	# one dimensional table,restrict choices to "n" and "total"
	if (length(dim(tbl))==1) {
		type<-ifelse(type=="n","n","total")
	}

	# if the object is an ftable, use the row.vars and col.vars
	# use numeric indices to avoid finding the omitted
	# the object must be converted to a table to get the dimensions right
	if (class(tbl)=="ftable") {
		nrowvar<-length(names(attr(tbl,"row.vars")))
		row.vars<-1:nrowvar
		col.vars<-(1:length(names(attr(tbl,"col.vars"))))+nrowvar
		tbl<-as.table(tbl)
	}

	# use row.vars and col.vars to determine the
	# marginals to use when calculating percentages
	# start by translating names to variable positions
	nms<-names(dimnames(tbl))
	if (!is.null(row.vars) && !is.numeric(row.vars)) {
		row.vars<-order(match(nms,row.vars),na.last=NA)
	}
	if (!is.null(col.vars) && !is.numeric(col.vars)) {
		col.vars<-order(match(nms,col.vars),na.last=NA)
	}
	# calculate the other if only one is given
	if (!is.null(row.vars) && is.null(col.vars)) {
		col.vars<-(1:length(dim(tbl)))[-row.vars]
	}
	if (!is.null(col.vars) && is.null(row.vars)) {
		row.vars<-(1:length(dim(tbl)))[-col.vars]
	}

	if (type[1] == "n") {
		newtab <- tbl
	}
	else {
		newtab<-mk.pcnt.tbl(tbl,type[1],row.vars=row.vars,col.vars=col.vars,percentages)
	}
	if (length(type) > 1) {
		# create the (percentage) tables, then convert them to data frames
		# stack the data frames, adding a new variable as percentage type
		tbldat<-as.data.frame.table(newtab)
		nms
		#tbldat$Type<-type[1]

		for (i in 2:length(type)) {
			if (type[i] == "n") {
				newtab <- tbl
			}
			else {
				newtab<-mk.pcnt.tbl(tbl,type[i],row.vars=row.vars,col.vars=col.vars,percentages)
			}
			newtab<-as.data.frame.table(newtab)
			newtab$Type<-type[i]
			tbldat<-rbind(tbldat,newtab)
		}
		tbldat$Type<-as.factor(tbldat$Type)
		xfrm<-"xtabs(Freq ~"
		for (nm in nms) xfrm<-paste(xfrm,nm,"+")
		xfrm<-paste(xfrm,"Type,data=tbldat)")
		newtab<-eval(parse(text=xfrm))
	}

	result<-NULL
	result$row.vars<-row.vars
	result$col.vars<-col.vars
	result$digits<-digits
	result$type<-type
	result$tbl<-newtab
	class(result)<-"ctab"
	result
}

print.ctab<-function(x,...) {
	# use ftable for more than 2 dimensions
	# (ftable doesn't work for 1 dimension,
	# and table is nicer for 2 dimensions IMHO
	row.vars<-x$row.vars
	col.vars<-x$col.vars
	if (length(dim(x$tbl))>2) {
		if (is.null(row.vars)) {
			# let the second variable be the column variable
			#row.vars<-names(dimnames(x$tbl))[-2]
			# reverse the order, last variables are groups, first is row variable
			#row.vars<-rev(row.vars)

			# following ftable conventions, the last variable is the column variable
			nms<-names(dimnames(x$tbl))
			row.vars<-nms[-length(nms)]
		}
		x$tbl<-ftable(x$tbl,row.vars=row.vars,col.vars=col.vars)
	}

	# get the names of the column variable
	if (class(x$tbl)=="ftable") {
		nms<-attr(x$tbl,"col.vars")[[1]]
	}
	else if (length(dim(x$tbl))==1) {
		nms<-dimnames(x$tbl)[[1]]
	}
	else{
		nms<-dimnames(x$tbl)[[2]]
	}

	# present the (percentage) table
	wd<-max(nchar(nms),nchar(as.integer(x$tbl))+x$digits+1)
	#print(formatC(x$tbl,format="f",width=wd,digits=x$digits))
	#tbl<-round(x$tbl,digits=2)
	tbl<-x$tbl
	tbl[!is.finite(tbl)]<-0
	tbl<-formatC(x$tbl,format="f",width=wd,digits=x$digits)
	#tbl[grep("NaN",tbl)]<-"   "
	print(tbl)
}

match.arglist<-function(vec,choices) {
	result<-NULL
	for(arg in vec) result<-c(result,match.arg(arg,choices))
	result
}

mk.pcnt.tbl<-function(tbl,type,row.vars=NULL,col.vars=NULL,percentages) {
	# marginals to exclude assuming first factor is the row variable,
	# second factor is the column variable
	# is overridden by row.vars or col.vars
	mrg2drop<-0
	if (type=="column") {mrg2drop<-1}
	if (type=="row") {mrg2drop<-2}
	if (type=="total" && length(dim(tbl)) > 1) {mrg2drop<-c(1,2)}

	# now determine the margin as the last element
	if (type=="row" && !is.null(col.vars)) {
		mrg2drop<-col.vars[length(col.vars)]
	}
	if (type=="column" && !is.null(row.vars)) {
		mrg2drop<-row.vars[length(row.vars)]
	}
	# if row.vars is given, col.vars has been determined
	if (type=="total" && !is.null(row.vars)) {
		mrg2drop<-c(col.vars[length(col.vars)],row.vars[length(row.vars)])
	}

	marg<-(1:length(dim(tbl)))[(-mrg2drop)]

	# create percentages
	tbl<-prop.table(tbl,marg)
	if (percentages) {tbl<-tbl*100}
	tbl<-round(tbl,digits=2)
	tbl
}
